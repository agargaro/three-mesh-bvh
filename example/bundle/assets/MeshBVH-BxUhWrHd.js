import{B as Pn,V as z,n as nt,dC as Pt,aQ as ft,o as pn,dD as Rn,b as j,J as Mt,U as xt,y as Dn,t as Fn,aP as Mn,x as yn}from"./ExtendedTriangle-CVugowSw.js";const Sn=0,Nn=1,Vn=2,Vi=0,$i=1,xn=2,jt=1.25,An=1,bt=32,Xt=65535,$n=Math.pow(2,-24),Yt=Symbol("SKIP_GENERATION");function In(i){return i.index?i.index.count:i.attributes.position.count}function ut(i){return In(i)/3}function kn(i,n=ArrayBuffer){return i>65535?new Uint32Array(new n(4*i)):new Uint16Array(new n(2*i))}function qn(i,n){if(!i.index){const t=i.attributes.position.count,e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=kn(t,e);i.setIndex(new Pn(s,1));for(let c=0;c<t;c++)s[c]=c}}function Cn(i,n){const t=ut(i),e=n||i.drawRange,s=e.start/3,c=(e.start+e.count)/3,r=Math.max(0,s),l=Math.min(t,c)-r;return[{offset:Math.floor(r),count:Math.floor(l)}]}function Un(i,n){if(!i.groups||!i.groups.length)return Cn(i,n);const t=[],e=new Set,s=n||i.drawRange,c=s.start/3,r=(s.start+s.count)/3;for(const o of i.groups){const y=o.start/3,f=(o.start+o.count)/3;e.add(Math.max(c,y)),e.add(Math.min(r,f))}const l=Array.from(e.values()).sort((o,y)=>o-y);for(let o=0;o<l.length-1;o++){const y=l[o],f=l[o+1];t.push({offset:Math.floor(y),count:Math.floor(f-y)})}return t}function Xn(i,n){const t=ut(i),e=Un(i,n).sort((r,l)=>r.offset-l.offset),s=e[e.length-1];s.count=Math.min(t-s.offset,s.count);let c=0;return e.forEach(({count:r})=>c+=r),t!==c}function Zt(i,n,t,e,s){let c=1/0,r=1/0,l=1/0,o=-1/0,y=-1/0,f=-1/0,u=1/0,a=1/0,p=1/0,d=-1/0,b=-1/0,g=-1/0;for(let h=n*6,x=(n+t)*6;h<x;h+=6){const m=i[h+0],w=i[h+1],A=m-w,T=m+w;A<c&&(c=A),T>o&&(o=T),m<u&&(u=m),m>d&&(d=m);const B=i[h+2],P=i[h+3],S=B-P,M=B+P;S<r&&(r=S),M>y&&(y=M),B<a&&(a=B),B>b&&(b=B);const U=i[h+4],_=i[h+5],C=U-_,L=U+_;C<l&&(l=C),L>f&&(f=L),U<p&&(p=U),U>g&&(g=U)}e[0]=c,e[1]=r,e[2]=l,e[3]=o,e[4]=y,e[5]=f,s[0]=u,s[1]=a,s[2]=p,s[3]=d,s[4]=b,s[5]=g}function Hn(i,n=null,t=null,e=null){const s=i.attributes.position,c=i.index?i.index.array:null,r=ut(i),l=s.normalized;let o;n===null?(o=new Float32Array(r*6),t=0,e=r):(o=n,t=t||0,e=e||r);const y=s.array,f=s.offset||0;let u=3;s.isInterleavedBufferAttribute&&(u=s.data.stride);const a=["getX","getY","getZ"];for(let p=t;p<t+e;p++){const d=p*3,b=p*6;let g=d+0,h=d+1,x=d+2;c&&(g=c[g],h=c[h],x=c[x]),l||(g=g*u+f,h=h*u+f,x=x*u+f);for(let m=0;m<3;m++){let w,A,T;l?(w=s[a[m]](g),A=s[a[m]](h),T=s[a[m]](x)):(w=y[g+m],A=y[h+m],T=y[x+m]);let B=w;A<B&&(B=A),T<B&&(B=T);let P=w;A>P&&(P=A),T>P&&(P=T);const S=(P-B)/2,M=m*2;o[b+M+0]=B+S,o[b+M+1]=S+(Math.abs(B)+S)*$n}}return o}function R(i,n,t){return t.min.x=n[i],t.min.y=n[i+1],t.min.z=n[i+2],t.max.x=n[i+3],t.max.y=n[i+4],t.max.z=n[i+5],t}function mn(i){let n=-1,t=-1/0;for(let e=0;e<3;e++){const s=i[e+3]-i[e];s>t&&(t=s,n=e)}return n}function hn(i,n){n.set(i)}function gn(i,n,t){let e,s;for(let c=0;c<3;c++){const r=c+3;e=i[c],s=n[c],t[c]=e<s?e:s,e=i[r],s=n[r],t[r]=e>s?e:s}}function St(i,n,t){for(let e=0;e<3;e++){const s=n[i+2*e],c=n[i+2*e+1],r=s-c,l=s+c;r<t[e]&&(t[e]=r),l>t[e+3]&&(t[e+3]=l)}}function At(i){const n=i[3]-i[0],t=i[4]-i[1],e=i[5]-i[2];return 2*(n*t+t*e+e*n)}const Y=32,jn=(i,n)=>i.candidate-n.candidate,K=new Array(Y).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ct=new Float32Array(6);function Yn(i,n,t,e,s,c){let r=-1,l=0;if(c===Sn)r=mn(n),r!==-1&&(l=(n[r]+n[r+3])/2);else if(c===Nn)r=mn(i),r!==-1&&(l=Zn(t,e,s,r));else if(c===Vn){const o=At(i);let y=jt*s;const f=e*6,u=(e+s)*6;for(let a=0;a<3;a++){const p=n[a],g=(n[a+3]-p)/Y;if(s<Y/4){const h=[...K];h.length=s;let x=0;for(let w=f;w<u;w+=6,x++){const A=h[x];A.candidate=t[w+2*a],A.count=0;const{bounds:T,leftCacheBounds:B,rightCacheBounds:P}=A;for(let S=0;S<3;S++)P[S]=1/0,P[S+3]=-1/0,B[S]=1/0,B[S+3]=-1/0,T[S]=1/0,T[S+3]=-1/0;St(w,t,T)}h.sort(jn);let m=s;for(let w=0;w<m;w++){const A=h[w];for(;w+1<m&&h[w+1].candidate===A.candidate;)h.splice(w+1,1),m--}for(let w=f;w<u;w+=6){const A=t[w+2*a];for(let T=0;T<m;T++){const B=h[T];A>=B.candidate?St(w,t,B.rightCacheBounds):(St(w,t,B.leftCacheBounds),B.count++)}}for(let w=0;w<m;w++){const A=h[w],T=A.count,B=s-A.count,P=A.leftCacheBounds,S=A.rightCacheBounds;let M=0;T!==0&&(M=At(P)/o);let U=0;B!==0&&(U=At(S)/o);const _=An+jt*(M*T+U*B);_<y&&(r=a,y=_,l=A.candidate)}}else{for(let m=0;m<Y;m++){const w=K[m];w.count=0,w.candidate=p+g+m*g;const A=w.bounds;for(let T=0;T<3;T++)A[T]=1/0,A[T+3]=-1/0}for(let m=f;m<u;m+=6){let T=~~((t[m+2*a]-p)/g);T>=Y&&(T=Y-1);const B=K[T];B.count++,St(m,t,B.bounds)}const h=K[Y-1];hn(h.bounds,h.rightCacheBounds);for(let m=Y-2;m>=0;m--){const w=K[m],A=K[m+1];gn(w.bounds,A.rightCacheBounds,w.rightCacheBounds)}let x=0;for(let m=0;m<Y-1;m++){const w=K[m],A=w.count,T=w.bounds,P=K[m+1].rightCacheBounds;A!==0&&(x===0?hn(T,Ct):gn(T,Ct,Ct)),x+=A;let S=0,M=0;x!==0&&(S=At(Ct)/o);const U=s-x;U!==0&&(M=At(P)/o);const _=An+jt*(S*x+M*U);_<y&&(r=a,y=_,l=w.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${c} used.`);return{axis:r,pos:l}}function Zn(i,n,t,e){let s=0;for(let c=n,r=n+t;c<r;c++)s+=i[c*6+e*2];return s/t}class Kt{constructor(){this.boundingData=new Float32Array(6)}}function Kn(i,n,t,e,s,c){let r=e,l=e+s-1;const o=c.pos,y=c.axis*2;for(;;){for(;r<=l&&t[r*6+y]<o;)r++;for(;r<=l&&t[l*6+y]>=o;)l--;if(r<l){for(let f=0;f<3;f++){let u=n[r*3+f];n[r*3+f]=n[l*3+f],n[l*3+f]=u}for(let f=0;f<6;f++){let u=t[r*6+f];t[r*6+f]=t[l*6+f],t[l*6+f]=u}r++,l--}else return r}}function Jn(i,n,t,e,s,c){let r=e,l=e+s-1;const o=c.pos,y=c.axis*2;for(;;){for(;r<=l&&t[r*6+y]<o;)r++;for(;r<=l&&t[l*6+y]>=o;)l--;if(r<l){let f=i[r];i[r]=i[l],i[l]=f;for(let u=0;u<6;u++){let a=t[r*6+u];t[r*6+u]=t[l*6+u],t[l*6+u]=a}r++,l--}else return r}}function V(i,n){return n[i+15]===65535}function $(i,n){return n[i+6]}function I(i,n){return n[i+14]}function k(i){return i+8}function q(i,n){return n[i+6]}function Ln(i,n){return n[i+7]}function Ii(i){return i}let En,Tt,kt,zn;const Qn=Math.pow(2,32);function nn(i){return"count"in i?1:1+nn(i.left)+nn(i.right)}function Wn(i,n,t){return En=new Float32Array(t),Tt=new Uint32Array(t),kt=new Uint16Array(t),zn=new Uint8Array(t),en(i,n)}function en(i,n){const t=i/4,e=i/2,s="count"in n,c=n.boundingData;for(let r=0;r<6;r++)En[t+r]=c[r];if(s)if(n.buffer){const r=n.buffer;zn.set(new Uint8Array(r),i);for(let l=i,o=i+r.byteLength;l<o;l+=bt){const y=l/2;V(y,kt)||(Tt[l/4+6]+=t)}return i+r.byteLength}else{const r=n.offset,l=n.count;return Tt[t+6]=r,kt[e+14]=l,kt[e+15]=Xt,i+bt}else{const r=n.left,l=n.right,o=n.splitAxis;let y;if(y=en(i+bt,r),y/4>Qn)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Tt[t+6]=y/4,y=en(y,l),Tt[t+7]=o,y}}function Gn(i,n){const t=(i.index?i.index.count:i.attributes.position.count)/3,e=t>2**16,s=e?4:2,c=n?new SharedArrayBuffer(t*s):new ArrayBuffer(t*s),r=e?new Uint32Array(c):new Uint16Array(c);for(let l=0,o=r.length;l<o;l++)r[l]=l;return r}function On(i,n,t,e,s){const{maxDepth:c,verbose:r,maxLeafTris:l,strategy:o,onProgress:y,indirect:f}=s,u=i._indirectBuffer,a=i.geometry,p=a.index?a.index.array:null,d=f?Jn:Kn,b=ut(a),g=new Float32Array(6);let h=!1;const x=new Kt;return Zt(n,t,e,x.boundingData,g),w(x,t,e,g),x;function m(A){y&&y(A/b)}function w(A,T,B,P=null,S=0){if(!h&&S>=c&&(h=!0,r&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(a))),B<=l||S>=c)return m(T+B),A.offset=T,A.count=B,A;const M=Yn(A.boundingData,P,n,T,B,o);if(M.axis===-1)return m(T+B),A.offset=T,A.count=B,A;const U=d(u,p,n,T,B,M);if(U===T||U===T+B)m(T+B),A.offset=T,A.count=B;else{A.splitAxis=M.axis;const _=new Kt,C=T,L=U-T;A.left=_,Zt(n,C,L,_.boundingData,g),w(_,C,L,g,S+1);const E=new Kt,D=U,Z=B-L;A.right=E,Zt(n,D,Z,E.boundingData,g),w(E,D,Z,g,S+1)}return A}}function ti(i,n){const t=i.geometry;n.indirect&&(i._indirectBuffer=Gn(t,n.useSharedArrayBuffer),Xn(t,n.range)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),i._indirectBuffer||qn(t,n);const e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Hn(t),c=n.indirect?Cn(t,n.range):Un(t,n.range);i._roots=c.map(r=>{const l=On(i,s,r.offset,r.count,n),o=nn(l),y=new e(bt*o);return Wn(0,l,y),y})}class N{constructor(n,t,e){this.isOrientedBox=!0,this.min=new z,this.max=new z,this.matrix=new nt,this.invMatrix=new nt,this.points=new Array(8).fill().map(()=>new z),this.satAxes=new Array(3).fill().map(()=>new z),this.satBounds=new Array(3).fill().map(()=>new Pt),this.alignedSatBounds=new Array(3).fill().map(()=>new Pt),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),e&&this.matrix.copy(e)}set(n,t,e){this.min.copy(n),this.max.copy(t),this.matrix.copy(e),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}N.prototype.update=(function(){return function(){const n=this.matrix,t=this.min,e=this.max,s=this.points;for(let y=0;y<=1;y++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){const a=1*y|2*f|4*u,p=s[a];p.x=y?e.x:t.x,p.y=f?e.y:t.y,p.z=u?e.z:t.z,p.applyMatrix4(n)}const c=this.satBounds,r=this.satAxes,l=s[0];for(let y=0;y<3;y++){const f=r[y],u=c[y],a=1<<y,p=s[a];f.subVectors(l,p),u.setFromPoints(f,s)}const o=this.alignedSatBounds;o[0].setFromPointsField(s,"x"),o[1].setFromPointsField(s,"y"),o[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();N.prototype.intersectsBox=(function(){const i=new Pt;return function(t){this.needsUpdate&&this.update();const e=t.min,s=t.max,c=this.satBounds,r=this.satAxes,l=this.alignedSatBounds;if(i.min=e.x,i.max=s.x,l[0].isSeparated(i)||(i.min=e.y,i.max=s.y,l[1].isSeparated(i))||(i.min=e.z,i.max=s.z,l[2].isSeparated(i)))return!1;for(let o=0;o<3;o++){const y=r[o],f=c[o];if(i.setFromBox(y,t),f.isSeparated(i))return!1}return!0}})();N.prototype.intersectsTriangle=(function(){const i=new ft,n=new Array(3),t=new Pt,e=new Pt,s=new z;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(i.copy(r),i.update(),r=i);const l=this.satBounds,o=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let a=0;a<3;a++){const p=l[a],d=o[a];if(t.setFromPoints(d,n),p.isSeparated(t))return!1}const y=r.satBounds,f=r.satAxes,u=this.points;for(let a=0;a<3;a++){const p=y[a],d=f[a];if(t.setFromPoints(d,u),p.isSeparated(t))return!1}for(let a=0;a<3;a++){const p=o[a];for(let d=0;d<4;d++){const b=f[d];if(s.crossVectors(p,b),t.setFromPoints(s,n),e.setFromPoints(s,u),t.isSeparated(e))return!1}}return!0}})();N.prototype.closestPointToPoint=(function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}})();N.prototype.distanceToPoint=(function(){const i=new z;return function(t){return this.closestPointToPoint(t,i),t.distanceTo(i)}})();N.prototype.distanceToBox=(function(){const i=["x","y","z"],n=new Array(12).fill().map(()=>new pn),t=new Array(12).fill().map(()=>new pn),e=new z,s=new z;return function(r,l=0,o=null,y=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(o||y)&&(r.getCenter(s),this.closestPointToPoint(s,e),r.closestPointToPoint(e,s),o&&o.copy(e),y&&y.copy(s)),0;const f=l*l,u=r.min,a=r.max,p=this.points;let d=1/0;for(let g=0;g<8;g++){const h=p[g];s.copy(h).clamp(u,a);const x=h.distanceToSquared(s);if(x<d&&(d=x,o&&o.copy(h),y&&y.copy(s),x<f))return Math.sqrt(x)}let b=0;for(let g=0;g<3;g++)for(let h=0;h<=1;h++)for(let x=0;x<=1;x++){const m=(g+1)%3,w=(g+2)%3,A=h<<m|x<<w,T=1<<g|h<<m|x<<w,B=p[A],P=p[T];n[b].set(B,P);const M=i[g],U=i[m],_=i[w],C=t[b],L=C.start,E=C.end;L[M]=u[M],L[U]=h?u[U]:a[U],L[_]=x?u[_]:a[U],E[M]=a[M],E[U]=h?u[U]:a[U],E[_]=x?u[_]:a[U],b++}for(let g=0;g<=1;g++)for(let h=0;h<=1;h++)for(let x=0;x<=1;x++){s.x=g?a.x:u.x,s.y=h?a.y:u.y,s.z=x?a.z:u.z,this.closestPointToPoint(s,e);const m=s.distanceToSquared(e);if(m<d&&(d=m,o&&o.copy(e),y&&y.copy(s),m<f))return Math.sqrt(m)}for(let g=0;g<12;g++){const h=n[g];for(let x=0;x<12;x++){const m=t[x];Rn(h,m,e,s);const w=e.distanceToSquared(s);if(w<d&&(d=w,o&&o.copy(e),y&&y.copy(s),w<f))return Math.sqrt(w)}}return Math.sqrt(d)}})();class un{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class ni extends un{constructor(){super(()=>new ft)}}const X=new ni;class ii{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=e=>{t&&n.push(t),t=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const v=new ii;let Q,at;const it=[],Ut=new un(()=>new j);function ei(i,n,t,e,s,c){Q=Ut.getPrimitive(),at=Ut.getPrimitive(),it.push(Q,at),v.setBuffer(i._roots[n]);const r=sn(0,i.geometry,t,e,s,c);v.clearBuffer(),Ut.releasePrimitive(Q),Ut.releasePrimitive(at),it.pop(),it.pop();const l=it.length;return l>0&&(at=it[l-1],Q=it[l-2]),r}function sn(i,n,t,e,s=null,c=0,r=0){const{float32Array:l,uint16Array:o,uint32Array:y}=v;let f=i*2;if(V(f,o)){const a=$(i,y),p=I(f,o);return R(i,l,Q),e(a,p,!1,r,c+i,Q)}else{let M=function(_){const{uint16Array:C,uint32Array:L}=v;let E=_*2;for(;!V(E,C);)_=k(_),E=_*2;return $(_,L)},U=function(_){const{uint16Array:C,uint32Array:L}=v;let E=_*2;for(;!V(E,C);)_=q(_,L),E=_*2;return $(_,L)+I(E,C)};const a=k(i),p=q(i,y);let d=a,b=p,g,h,x,m;if(s&&(x=Q,m=at,R(d,l,x),R(b,l,m),g=s(x),h=s(m),h<g)){d=p,b=a;const _=g;g=h,h=_,x=m}x||(x=Q,R(d,l,x));const w=V(d*2,o),A=t(x,w,g,r+1,c+d);let T;if(A===xn){const _=M(d),L=U(d)-_;T=e(_,L,!0,r+1,c+d,x)}else T=A&&sn(d,n,t,e,s,c,r+1);if(T)return!0;m=at,R(b,l,m);const B=V(b*2,o),P=t(m,B,h,r+1,c+b);let S;if(P===xn){const _=M(b),L=U(b)-_;S=e(_,L,!0,r+1,c+b,m)}else S=P&&sn(b,n,t,e,s,c,r+1);return!!S}}const mt=new z,Jt=new z;function si(i,n,t={},e=0,s=1/0){const c=e*e,r=s*s;let l=1/0,o=null;if(i.shapecast({boundsTraverseOrder:f=>(mt.copy(n).clamp(f.min,f.max),mt.distanceToSquared(n)),intersectsBounds:(f,u,a)=>a<l&&a<r,intersectsTriangle:(f,u)=>{f.closestPointToPoint(n,mt);const a=n.distanceToSquared(mt);return a<l&&(Jt.copy(mt),l=a,o=u),a<c}}),l===1/0)return null;const y=Math.sqrt(l);return t.point?t.point.copy(Jt):t.point=Jt.clone(),t.distance=y,t.faceIndex=o,t}const Lt=parseInt(Mn)>=169,ri=parseInt(Mn)<=161,G=new z,O=new z,tt=new z,Et=new Mt,zt=new Mt,vt=new Mt,wn=new z,Bn=new z,dn=new z,ht=new z;function oi(i,n,t,e,s,c,r,l){let o;if(c===Dn?o=i.intersectTriangle(e,t,n,!0,s):o=i.intersectTriangle(n,t,e,c!==Fn,s),o===null)return null;const y=i.origin.distanceTo(s);return y<r||y>l?null:{distance:y,point:s.clone()}}function ci(i,n,t,e,s,c,r,l,o,y,f){G.fromBufferAttribute(n,c),O.fromBufferAttribute(n,r),tt.fromBufferAttribute(n,l);const u=oi(i,G,O,tt,ht,o,y,f);if(u){if(e){Et.fromBufferAttribute(e,c),zt.fromBufferAttribute(e,r),vt.fromBufferAttribute(e,l),u.uv=new Mt;const p=xt.getInterpolation(ht,G,O,tt,Et,zt,vt,u.uv);Lt||(u.uv=p)}if(s){Et.fromBufferAttribute(s,c),zt.fromBufferAttribute(s,r),vt.fromBufferAttribute(s,l),u.uv1=new Mt;const p=xt.getInterpolation(ht,G,O,tt,Et,zt,vt,u.uv1);Lt||(u.uv1=p),ri&&(u.uv2=u.uv1)}if(t){wn.fromBufferAttribute(t,c),Bn.fromBufferAttribute(t,r),dn.fromBufferAttribute(t,l),u.normal=new z;const p=xt.getInterpolation(ht,G,O,tt,wn,Bn,dn,u.normal);u.normal.dot(i.direction)>0&&u.normal.multiplyScalar(-1),Lt||(u.normal=p)}const a={a:c,b:r,c:l,normal:new z,materialIndex:0};if(xt.getNormal(G,O,tt,a.normal),u.face=a,u.faceIndex=c,Lt){const p=new z;xt.getBarycoord(ht,G,O,tt,p),u.barycoord=p}}return u}function Ht(i,n,t,e,s,c,r){const l=e*3;let o=l+0,y=l+1,f=l+2;const u=i.index;i.index&&(o=u.getX(o),y=u.getX(y),f=u.getX(f));const{position:a,normal:p,uv:d,uv1:b}=i.attributes,g=ci(t,a,p,d,b,o,y,f,n,c,r);return g?(g.faceIndex=e,s&&s.push(g),g):null}function F(i,n,t,e){const s=i.a,c=i.b,r=i.c;let l=n,o=n+1,y=n+2;t&&(l=t.getX(l),o=t.getX(o),y=t.getX(y)),s.x=e.getX(l),s.y=e.getY(l),s.z=e.getZ(l),c.x=e.getX(o),c.y=e.getY(o),c.z=e.getZ(o),r.x=e.getX(y),r.y=e.getY(y),r.z=e.getZ(y)}function li(i,n,t,e,s,c,r,l){const{geometry:o,_indirectBuffer:y}=i;for(let f=e,u=e+s;f<u;f++)Ht(o,n,t,f,c,r,l)}function ai(i,n,t,e,s,c,r){const{geometry:l,_indirectBuffer:o}=i;let y=1/0,f=null;for(let u=e,a=e+s;u<a;u++){let p;p=Ht(l,n,t,u,null,c,r),p&&p.distance<y&&(f=p,y=p.distance)}return f}function fi(i,n,t,e,s,c,r){const{geometry:l}=t,{index:o}=l,y=l.attributes.position;for(let f=i,u=n+i;f<u;f++){let a;if(a=f,F(r,a*3,o,y),r.needsUpdate=!0,e(r,a,s,c))return!0}return!1}function ui(i,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=i.geometry,e=t.index?t.index.array:null,s=t.attributes.position;let c,r,l,o,y=0;const f=i._roots;for(let a=0,p=f.length;a<p;a++)c=f[a],r=new Uint32Array(c),l=new Uint16Array(c),o=new Float32Array(c),u(0,y),y+=c.byteLength;function u(a,p,d=!1){const b=a*2;if(l[b+15]===Xt){const h=r[a+6],x=l[b+14];let m=1/0,w=1/0,A=1/0,T=-1/0,B=-1/0,P=-1/0;for(let S=3*h,M=3*(h+x);S<M;S++){let U=e[S];const _=s.getX(U),C=s.getY(U),L=s.getZ(U);_<m&&(m=_),_>T&&(T=_),C<w&&(w=C),C>B&&(B=C),L<A&&(A=L),L>P&&(P=L)}return o[a+0]!==m||o[a+1]!==w||o[a+2]!==A||o[a+3]!==T||o[a+4]!==B||o[a+5]!==P?(o[a+0]=m,o[a+1]=w,o[a+2]=A,o[a+3]=T,o[a+4]=B,o[a+5]=P,!0):!1}else{const h=a+8,x=r[a+6],m=h+p,w=x+p;let A=d,T=!1,B=!1;n?A||(T=n.has(m),B=n.has(w),A=!T&&!B):(T=!0,B=!0);const P=A||T,S=A||B;let M=!1;P&&(M=u(h,p,A));let U=!1;S&&(U=u(x,p,A));const _=M||U;if(_)for(let C=0;C<3;C++){const L=h+C,E=x+C,D=o[L],Z=o[L+3],pt=o[E],yt=o[E+3];o[a+C]=D<pt?D:pt,o[a+C+3]=Z>yt?Z:yt}return _}}}function W(i,n,t,e,s){let c,r,l,o,y,f;const u=1/t.direction.x,a=1/t.direction.y,p=1/t.direction.z,d=t.origin.x,b=t.origin.y,g=t.origin.z;let h=n[i],x=n[i+3],m=n[i+1],w=n[i+3+1],A=n[i+2],T=n[i+3+2];return u>=0?(c=(h-d)*u,r=(x-d)*u):(c=(x-d)*u,r=(h-d)*u),a>=0?(l=(m-b)*a,o=(w-b)*a):(l=(w-b)*a,o=(m-b)*a),c>o||l>r||((l>c||isNaN(c))&&(c=l),(o<r||isNaN(r))&&(r=o),p>=0?(y=(A-g)*p,f=(T-g)*p):(y=(T-g)*p,f=(A-g)*p),c>f||y>r)?!1:((y>c||c!==c)&&(c=y),(f<r||r!==r)&&(r=f),c<=s&&r>=e)}function pi(i,n,t,e,s,c,r,l){const{geometry:o,_indirectBuffer:y}=i;for(let f=e,u=e+s;f<u;f++){let a=y?y[f]:f;Ht(o,n,t,a,c,r,l)}}function yi(i,n,t,e,s,c,r){const{geometry:l,_indirectBuffer:o}=i;let y=1/0,f=null;for(let u=e,a=e+s;u<a;u++){let p;p=Ht(l,n,t,o?o[u]:u,null,c,r),p&&p.distance<y&&(f=p,y=p.distance)}return f}function xi(i,n,t,e,s,c,r){const{geometry:l}=t,{index:o}=l,y=l.attributes.position;for(let f=i,u=n+i;f<u;f++){let a;if(a=t.resolveTriangleIndex(f),F(r,a*3,o,y),r.needsUpdate=!0,e(r,a,s,c))return!0}return!1}function Ai(i,n,t,e,s,c,r){v.setBuffer(i._roots[n]),rn(0,i,t,e,s,c,r),v.clearBuffer()}function rn(i,n,t,e,s,c,r){const{float32Array:l,uint16Array:o,uint32Array:y}=v,f=i*2;if(V(f,o)){const a=$(i,y),p=I(f,o);li(n,t,e,a,p,s,c,r)}else{const a=k(i);W(a,l,e,c,r)&&rn(a,n,t,e,s,c,r);const p=q(i,y);W(p,l,e,c,r)&&rn(p,n,t,e,s,c,r)}}const mi=["x","y","z"];function hi(i,n,t,e,s,c){v.setBuffer(i._roots[n]);const r=on(0,i,t,e,s,c);return v.clearBuffer(),r}function on(i,n,t,e,s,c){const{float32Array:r,uint16Array:l,uint32Array:o}=v;let y=i*2;if(V(y,l)){const u=$(i,o),a=I(y,l);return ai(n,t,e,u,a,s,c)}else{const u=Ln(i,o),a=mi[u],d=e.direction[a]>=0;let b,g;d?(b=k(i),g=q(i,o)):(b=q(i,o),g=k(i));const x=W(b,r,e,s,c)?on(b,n,t,e,s,c):null;if(x){const A=x.point[a];if(d?A<=r[g+u]:A>=r[g+u+3])return x}const w=W(g,r,e,s,c)?on(g,n,t,e,s,c):null;return x&&w?x.distance<=w.distance?x:w:x||w||null}}const Rt=new j,et=new ft,st=new ft,gt=new nt,Tn=new N,Dt=new N;function gi(i,n,t,e){v.setBuffer(i._roots[n]);const s=cn(0,i,t,e);return v.clearBuffer(),s}function cn(i,n,t,e,s=null){const{float32Array:c,uint16Array:r,uint32Array:l}=v;let o=i*2;if(s===null&&(t.boundingBox||t.computeBoundingBox(),Tn.set(t.boundingBox.min,t.boundingBox.max,e),s=Tn),V(o,r)){const f=n.geometry,u=f.index,a=f.attributes.position,p=t.index,d=t.attributes.position,b=$(i,l),g=I(o,r);if(gt.copy(e).invert(),t.boundsTree)return R(i,c,Dt),Dt.matrix.copy(gt),Dt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>Dt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(e),x.b.applyMatrix4(e),x.c.applyMatrix4(e),x.needsUpdate=!0;for(let m=b*3,w=(g+b)*3;m<w;m+=3)if(F(st,m,u,a),st.needsUpdate=!0,x.intersectsTriangle(st))return!0;return!1}});for(let h=b*3,x=(g+b)*3;h<x;h+=3){F(et,h,u,a),et.a.applyMatrix4(gt),et.b.applyMatrix4(gt),et.c.applyMatrix4(gt),et.needsUpdate=!0;for(let m=0,w=p.count;m<w;m+=3)if(F(st,m,p,d),st.needsUpdate=!0,et.intersectsTriangle(st))return!0}}else{const f=i+8,u=l[i+6];return R(f,c,Rt),!!(s.intersectsBox(Rt)&&cn(f,n,t,e,s)||(R(u,c,Rt),s.intersectsBox(Rt)&&cn(u,n,t,e,s)))}}const Ft=new nt,Qt=new N,wt=new N,wi=new z,Bi=new z,di=new z,Ti=new z;function bi(i,n,t,e={},s={},c=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Qt.set(n.boundingBox.min,n.boundingBox.max,t),Qt.needsUpdate=!0;const l=i.geometry,o=l.attributes.position,y=l.index,f=n.attributes.position,u=n.index,a=X.getPrimitive(),p=X.getPrimitive();let d=wi,b=Bi,g=null,h=null;s&&(g=di,h=Ti);let x=1/0,m=null,w=null;return Ft.copy(t).invert(),wt.matrix.copy(Ft),i.shapecast({boundsTraverseOrder:A=>Qt.distanceToBox(A),intersectsBounds:(A,T,B)=>B<x&&B<r?(T&&(wt.min.copy(A.min),wt.max.copy(A.max),wt.needsUpdate=!0),!0):!1,intersectsRange:(A,T)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:P=>wt.distanceToBox(P),intersectsBounds:(P,S,M)=>M<x&&M<r,intersectsRange:(P,S)=>{for(let M=P,U=P+S;M<U;M++){F(p,3*M,u,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let _=A,C=A+T;_<C;_++){F(a,3*_,y,o),a.needsUpdate=!0;const L=a.distanceToTriangle(p,d,g);if(L<x&&(b.copy(d),h&&h.copy(g),x=L,m=_,w=M),L<c)return!0}}}});{const B=ut(n);for(let P=0,S=B;P<S;P++){F(p,3*P,u,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let M=A,U=A+T;M<U;M++){F(a,3*M,y,o),a.needsUpdate=!0;const _=a.distanceToTriangle(p,d,g);if(_<x&&(b.copy(d),h&&h.copy(g),x=_,m=M,w=P),_<c)return!0}}}}}),X.releasePrimitive(a),X.releasePrimitive(p),x===1/0?null:(e.point?e.point.copy(b):e.point=b.clone(),e.distance=x,e.faceIndex=m,s&&(s.point?s.point.copy(h):s.point=h.clone(),s.point.applyMatrix4(Ft),b.applyMatrix4(Ft),s.distance=b.sub(s.point).length(),s.faceIndex=w),e)}function _i(i,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=i.geometry,e=t.index?t.index.array:null,s=t.attributes.position;let c,r,l,o,y=0;const f=i._roots;for(let a=0,p=f.length;a<p;a++)c=f[a],r=new Uint32Array(c),l=new Uint16Array(c),o=new Float32Array(c),u(0,y),y+=c.byteLength;function u(a,p,d=!1){const b=a*2;if(l[b+15]===Xt){const h=r[a+6],x=l[b+14];let m=1/0,w=1/0,A=1/0,T=-1/0,B=-1/0,P=-1/0;for(let S=h,M=h+x;S<M;S++){const U=3*i.resolveTriangleIndex(S);for(let _=0;_<3;_++){let C=U+_;C=e?e[C]:C;const L=s.getX(C),E=s.getY(C),D=s.getZ(C);L<m&&(m=L),L>T&&(T=L),E<w&&(w=E),E>B&&(B=E),D<A&&(A=D),D>P&&(P=D)}}return o[a+0]!==m||o[a+1]!==w||o[a+2]!==A||o[a+3]!==T||o[a+4]!==B||o[a+5]!==P?(o[a+0]=m,o[a+1]=w,o[a+2]=A,o[a+3]=T,o[a+4]=B,o[a+5]=P,!0):!1}else{const h=a+8,x=r[a+6],m=h+p,w=x+p;let A=d,T=!1,B=!1;n?A||(T=n.has(m),B=n.has(w),A=!T&&!B):(T=!0,B=!0);const P=A||T,S=A||B;let M=!1;P&&(M=u(h,p,A));let U=!1;S&&(U=u(x,p,A));const _=M||U;if(_)for(let C=0;C<3;C++){const L=h+C,E=x+C,D=o[L],Z=o[L+3],pt=o[E],yt=o[E+3];o[a+C]=D<pt?D:pt,o[a+C+3]=Z>yt?Z:yt}return _}}}function Pi(i,n,t,e,s,c,r){v.setBuffer(i._roots[n]),ln(0,i,t,e,s,c,r),v.clearBuffer()}function ln(i,n,t,e,s,c,r){const{float32Array:l,uint16Array:o,uint32Array:y}=v,f=i*2;if(V(f,o)){const a=$(i,y),p=I(f,o);pi(n,t,e,a,p,s,c,r)}else{const a=k(i);W(a,l,e,c,r)&&ln(a,n,t,e,s,c,r);const p=q(i,y);W(p,l,e,c,r)&&ln(p,n,t,e,s,c,r)}}const Mi=["x","y","z"];function Si(i,n,t,e,s,c){v.setBuffer(i._roots[n]);const r=an(0,i,t,e,s,c);return v.clearBuffer(),r}function an(i,n,t,e,s,c){const{float32Array:r,uint16Array:l,uint32Array:o}=v;let y=i*2;if(V(y,l)){const u=$(i,o),a=I(y,l);return yi(n,t,e,u,a,s,c)}else{const u=Ln(i,o),a=Mi[u],d=e.direction[a]>=0;let b,g;d?(b=k(i),g=q(i,o)):(b=q(i,o),g=k(i));const x=W(b,r,e,s,c)?an(b,n,t,e,s,c):null;if(x){const A=x.point[a];if(d?A<=r[g+u]:A>=r[g+u+3])return x}const w=W(g,r,e,s,c)?an(g,n,t,e,s,c):null;return x&&w?x.distance<=w.distance?x:w:x||w||null}}const Nt=new j,rt=new ft,ot=new ft,Bt=new nt,bn=new N,Vt=new N;function Ci(i,n,t,e){v.setBuffer(i._roots[n]);const s=fn(0,i,t,e);return v.clearBuffer(),s}function fn(i,n,t,e,s=null){const{float32Array:c,uint16Array:r,uint32Array:l}=v;let o=i*2;if(s===null&&(t.boundingBox||t.computeBoundingBox(),bn.set(t.boundingBox.min,t.boundingBox.max,e),s=bn),V(o,r)){const f=n.geometry,u=f.index,a=f.attributes.position,p=t.index,d=t.attributes.position,b=$(i,l),g=I(o,r);if(Bt.copy(e).invert(),t.boundsTree)return R(i,c,Vt),Vt.matrix.copy(Bt),Vt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>Vt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(e),x.b.applyMatrix4(e),x.c.applyMatrix4(e),x.needsUpdate=!0;for(let m=b,w=g+b;m<w;m++)if(F(ot,3*n.resolveTriangleIndex(m),u,a),ot.needsUpdate=!0,x.intersectsTriangle(ot))return!0;return!1}});for(let h=b,x=g+b;h<x;h++){const m=n.resolveTriangleIndex(h);F(rt,3*m,u,a),rt.a.applyMatrix4(Bt),rt.b.applyMatrix4(Bt),rt.c.applyMatrix4(Bt),rt.needsUpdate=!0;for(let w=0,A=p.count;w<A;w+=3)if(F(ot,w,p,d),ot.needsUpdate=!0,rt.intersectsTriangle(ot))return!0}}else{const f=i+8,u=l[i+6];return R(f,c,Nt),!!(s.intersectsBox(Nt)&&fn(f,n,t,e,s)||(R(u,c,Nt),s.intersectsBox(Nt)&&fn(u,n,t,e,s)))}}const $t=new nt,Wt=new N,dt=new N,Ui=new z,Li=new z,Ei=new z,zi=new z;function vi(i,n,t,e={},s={},c=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Wt.set(n.boundingBox.min,n.boundingBox.max,t),Wt.needsUpdate=!0;const l=i.geometry,o=l.attributes.position,y=l.index,f=n.attributes.position,u=n.index,a=X.getPrimitive(),p=X.getPrimitive();let d=Ui,b=Li,g=null,h=null;s&&(g=Ei,h=zi);let x=1/0,m=null,w=null;return $t.copy(t).invert(),dt.matrix.copy($t),i.shapecast({boundsTraverseOrder:A=>Wt.distanceToBox(A),intersectsBounds:(A,T,B)=>B<x&&B<r?(T&&(dt.min.copy(A.min),dt.max.copy(A.max),dt.needsUpdate=!0),!0):!1,intersectsRange:(A,T)=>{if(n.boundsTree){const B=n.boundsTree;return B.shapecast({boundsTraverseOrder:P=>dt.distanceToBox(P),intersectsBounds:(P,S,M)=>M<x&&M<r,intersectsRange:(P,S)=>{for(let M=P,U=P+S;M<U;M++){const _=B.resolveTriangleIndex(M);F(p,3*_,u,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let C=A,L=A+T;C<L;C++){const E=i.resolveTriangleIndex(C);F(a,3*E,y,o),a.needsUpdate=!0;const D=a.distanceToTriangle(p,d,g);if(D<x&&(b.copy(d),h&&h.copy(g),x=D,m=C,w=M),D<c)return!0}}}})}else{const B=ut(n);for(let P=0,S=B;P<S;P++){F(p,3*P,u,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let M=A,U=A+T;M<U;M++){const _=i.resolveTriangleIndex(M);F(a,3*_,y,o),a.needsUpdate=!0;const C=a.distanceToTriangle(p,d,g);if(C<x&&(b.copy(d),h&&h.copy(g),x=C,m=M,w=P),C<c)return!0}}}}}),X.releasePrimitive(a),X.releasePrimitive(p),x===1/0?null:(e.point?e.point.copy(b):e.point=b.clone(),e.distance=x,e.faceIndex=m,s&&(s.point?s.point.copy(h):s.point=h.clone(),s.point.applyMatrix4($t),b.applyMatrix4($t),s.distance=b.sub(s.point).length(),s.faceIndex=w),e)}function Ri(){return typeof SharedArrayBuffer<"u"}function ki(i,n){if(i===null)return i;if(i.buffer){const t=i.buffer;if(t.constructor===n)return i;const e=i.constructor,s=new e(new n(t.byteLength));return s.set(i),s}else{if(i.constructor===n)return i;const t=new n(i.byteLength);return new Uint8Array(t).set(new Uint8Array(i)),t}}const _t=new v.constructor,qt=new v.constructor,J=new un(()=>new j),ct=new j,lt=new j,Gt=new j,Ot=new j;let tn=!1;function Di(i,n,t,e){if(tn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");tn=!0;const s=i._roots,c=n._roots;let r,l=0,o=0;const y=new nt().copy(t).invert();for(let f=0,u=s.length;f<u;f++){_t.setBuffer(s[f]),o=0;const a=J.getPrimitive();R(0,_t.float32Array,a),a.applyMatrix4(y);for(let p=0,d=c.length;p<d&&(qt.setBuffer(c[p]),r=H(0,0,t,y,e,l,o,0,0,a),qt.clearBuffer(),o+=c[p].length,!r);p++);if(J.releasePrimitive(a),_t.clearBuffer(),l+=s[f].length,r)break}return tn=!1,r}function H(i,n,t,e,s,c=0,r=0,l=0,o=0,y=null,f=!1){let u,a;f?(u=qt,a=_t):(u=_t,a=qt);const p=u.float32Array,d=u.uint32Array,b=u.uint16Array,g=a.float32Array,h=a.uint32Array,x=a.uint16Array,m=i*2,w=n*2,A=V(m,b),T=V(w,x);let B=!1;if(T&&A)f?B=s($(n,h),I(n*2,x),$(i,d),I(i*2,b),o,r+n,l,c+i):B=s($(i,d),I(i*2,b),$(n,h),I(n*2,x),l,c+i,o,r+n);else if(T){const P=J.getPrimitive();R(n,g,P),P.applyMatrix4(t);const S=k(i),M=q(i,d);R(S,p,ct),R(M,p,lt);const U=P.intersectsBox(ct),_=P.intersectsBox(lt);B=U&&H(n,S,e,t,s,r,c,o,l+1,P,!f)||_&&H(n,M,e,t,s,r,c,o,l+1,P,!f),J.releasePrimitive(P)}else{const P=k(n),S=q(n,h);R(P,g,Gt),R(S,g,Ot);const M=y.intersectsBox(Gt),U=y.intersectsBox(Ot);if(M&&U)B=H(i,P,t,e,s,c,r,l,o+1,y,f)||H(i,S,t,e,s,c,r,l,o+1,y,f);else if(M)if(A)B=H(i,P,t,e,s,c,r,l,o+1,y,f);else{const _=J.getPrimitive();_.copy(Gt).applyMatrix4(t);const C=k(i),L=q(i,d);R(C,p,ct),R(L,p,lt);const E=_.intersectsBox(ct),D=_.intersectsBox(lt);B=E&&H(P,C,e,t,s,r,c,o,l+1,_,!f)||D&&H(P,L,e,t,s,r,c,o,l+1,_,!f),J.releasePrimitive(_)}else if(U)if(A)B=H(i,S,t,e,s,c,r,l,o+1,y,f);else{const _=J.getPrimitive();_.copy(Ot).applyMatrix4(t);const C=k(i),L=q(i,d);R(C,p,ct),R(L,p,lt);const E=_.intersectsBox(ct),D=_.intersectsBox(lt);B=E&&H(S,C,e,t,s,r,c,o,l+1,_,!f)||D&&H(S,L,e,t,s,r,c,o,l+1,_,!f),J.releasePrimitive(_)}}return B}const It=new N,_n=new j,Fi={strategy:Sn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class vn{static serialize(n,t={}){t={cloneBuffers:!0,...t};const e=n.geometry,s=n._roots,c=n._indirectBuffer,r=e.getIndex();let l;return t.cloneBuffers?l={roots:s.map(o=>o.slice()),index:r?r.array.slice():null,indirectBuffer:c?c.slice():null}:l={roots:s,index:r?r.array:null,indirectBuffer:c},l}static deserialize(n,t,e={}){e={setIndex:!0,indirect:!!n.indirectBuffer,...e};const{index:s,roots:c,indirectBuffer:r}=n,l=new vn(t,{...e,[Yt]:!0});if(l._roots=c,l._indirectBuffer=r||null,e.setIndex){const o=t.getIndex();if(o===null){const y=new Pn(n.index,1,!1);t.setIndex(y)}else o.array!==s&&(o.array.set(s),o.needsUpdate=!0)}return l}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({...Fi,[Yt]:!1},t),t.useSharedArrayBuffer&&!Ri())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[Yt]||(ti(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new j))),this.resolveTriangleIndex=t.indirect?e=>this._indirectBuffer[e]:e=>e}refit(n=null){return(this.indirect?_i:ui)(this,n)}traverse(n,t=0){const e=this._roots[t],s=new Uint32Array(e),c=new Uint16Array(e);r(0);function r(l,o=0){const y=l*2,f=c[y+15]===Xt;if(f){const u=s[l+6],a=c[y+14];n(o,f,new Float32Array(e,l*4,6),u,a)}else{const u=l+bt/4,a=s[l+6],p=s[l+7];n(o,f,new Float32Array(e,l*4,6),p)||(r(u,o+1),r(a,o+1))}}}raycast(n,t=yn,e=0,s=1/0){const c=this._roots,r=this.geometry,l=[],o=t.isMaterial,y=Array.isArray(t),f=r.groups,u=o?t.side:t,a=this.indirect?Pi:Ai;for(let p=0,d=c.length;p<d;p++){const b=y?t[f[p].materialIndex].side:u,g=l.length;if(a(this,p,b,n,l,e,s),y){const h=f[p].materialIndex;for(let x=g,m=l.length;x<m;x++)l[x].face.materialIndex=h}}return l}raycastFirst(n,t=yn,e=0,s=1/0){const c=this._roots,r=this.geometry,l=t.isMaterial,o=Array.isArray(t);let y=null;const f=r.groups,u=l?t.side:t,a=this.indirect?Si:hi;for(let p=0,d=c.length;p<d;p++){const b=o?t[f[p].materialIndex].side:u,g=a(this,p,b,n,e,s);g!=null&&(y==null||g.distance<y.distance)&&(y=g,o&&(g.face.materialIndex=f[p].materialIndex))}return y}intersectsGeometry(n,t){let e=!1;const s=this._roots,c=this.indirect?Ci:gi;for(let r=0,l=s.length;r<l&&(e=c(this,r,n,t),!e);r++);return e}shapecast(n){const t=X.getPrimitive(),e=this.indirect?xi:fi;let{boundsTraverseOrder:s,intersectsBounds:c,intersectsRange:r,intersectsTriangle:l}=n;if(r&&l){const u=r;r=(a,p,d,b,g)=>u(a,p,d,b,g)?!0:e(a,p,this,l,d,b,t)}else r||(l?r=(u,a,p,d)=>e(u,a,this,l,p,d,t):r=(u,a,p)=>p);let o=!1,y=0;const f=this._roots;for(let u=0,a=f.length;u<a;u++){const p=f[u];if(o=ei(this,u,c,r,s,y),o)break;y+=p.byteLength}return X.releasePrimitive(t),o}bvhcast(n,t,e){let{intersectsRanges:s,intersectsTriangles:c}=e;const r=X.getPrimitive(),l=this.geometry.index,o=this.geometry.attributes.position,y=this.indirect?d=>{const b=this.resolveTriangleIndex(d);F(r,b*3,l,o)}:d=>{F(r,d*3,l,o)},f=X.getPrimitive(),u=n.geometry.index,a=n.geometry.attributes.position,p=n.indirect?d=>{const b=n.resolveTriangleIndex(d);F(f,b*3,u,a)}:d=>{F(f,d*3,u,a)};if(c){const d=(b,g,h,x,m,w,A,T)=>{for(let B=h,P=h+x;B<P;B++){p(B),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let S=b,M=b+g;S<M;S++)if(y(S),r.needsUpdate=!0,c(r,f,S,B,m,w,A,T))return!0}return!1};if(s){const b=s;s=function(g,h,x,m,w,A,T,B){return b(g,h,x,m,w,A,T,B)?!0:d(g,h,x,m,w,A,T,B)}}else s=d}return Di(this,n,t,s)}intersectsBox(n,t){return It.set(n.min,n.max,t),It.needsUpdate=!0,this.shapecast({intersectsBounds:e=>It.intersectsBox(e),intersectsTriangle:e=>It.intersectsTriangle(e)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,e={},s={},c=0,r=1/0){return(this.indirect?vi:bi)(this,n,t,e,s,c,r)}closestPointToPoint(n,t={},e=0,s=1/0){return si(this,n,t,e,s)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(e=>{R(0,new Float32Array(e),_n),n.union(_n)}),n}}export{Nn as A,bt as B,Sn as C,$i as I,vn as M,Vi as N,$ as O,q as R,Vn as S,jt as T,xn as a,In as b,ki as c,V as d,qn as e,I as f,kn as g,Ln as h,Ri as i,Ii as j,An as k,R as l};
